public class BST_Closet_binary_search_tree_value_II {

}



/***
 * 时间复杂度O(lgn + k)。
 * 和I一样，先找出大于target最小值，和小于target的最大值。只不过这次要用两个stack储存中间结果。
 * 然后两个栈顶元素比较，取closer那个，pop出来，再把这个元素的左/右子树压栈（注释#）。直到找到k个结果。
 * 如果一个栈空了，从另外一个栈pop出剩下的元素。
 *
 * #：当lowbound的栈顶元素pop出来后，找次小于他的值，需要到他的左子树的右半边去找；
 * 同理，当highbound的栈顶元素pop出来后，找略大于他的值，需要到他的右子树的左半边去找。
 * 这是bst的性质决定的。其实和数组里面找k个临近值是一个原理，只不过数组通过两个指针左右移动就好。
 * 二叉树要麻烦很多，用low和high两个指针把所有候选临近元素压栈，然后通过pop栈顶元素来从近向远pop比较。
 */
